<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chord Transposer</title>
<link rel="icon" type="image/x-icon" href="/chords/favicon.png">

<style>
  :root{
    --accent:#5CB9FF;
    --bg:#2e2e2e;
    --text:#eaeaea;
  }

  /* page */
  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    max-width:900px;
    margin:2rem auto;
    padding:1rem;
    background:var(--bg);
    color:var(--text);
  }

  h1{ color:var(--accent); text-align:center; font-size:clamp(1.5rem,4vw,2.2rem); margin-bottom:0.5rem; }
  p{ color:var(--accent); text-align:center; margin-top:0; margin-bottom:1rem; }

  input[type="text"]{ width:96%; padding:0.5rem; margin:0 auto 1rem auto; display:block; font-size:1.1rem;
    border-radius:6px; border:1px solid #444; background:#1e1e1e; color:#e0e0e0; box-sizing:border-box;}
  textarea{ width:94%; min-height:220px; padding:0.75rem; margin:0 auto 1rem auto; display:block;
    border-radius:8px; border:1px solid #444; background:#1e1e1e; color:#e0e0e0; font-family:monospace; resize:vertical; box-sizing:border-box; }

  .controls{ display:flex; flex-wrap:wrap; gap:0.5rem; justify-content:center; margin-bottom:1rem; }
  .controls button{ flex:1 1 100px; background:#4da3ff; color:#fff; border:none; border-radius:8px; padding:0.6rem 1rem; cursor:pointer; }
  .controls button:hover{ background:#1e90ff; }

  .configs {
    font-size:16px;
    text-align:center;
  }

label {
}

.confs {
  display: inline-block;
  margin-bottom: 5px;
  width: 100%;
}

.ajuste {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  font-weight: 400;
  color: #fff;
  background: #4da3ff;
  border: 1px solid #007bff;
  border-radius: 2px;
  width: 40px;
  height: 20px;
  text-align: center;
}

.ajuste1 {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  font-weight: 400;
  color: #fff;
  background: #4da300;
  border: 1px solid #007b00;
  border-radius: 2px;
  width: 40px;
  height: 20px;
  text-align: center;
}


  details{ margin-bottom:1rem; background:#1e1e1e; padding:1rem; border-radius:8px; }
  details summary{ cursor:pointer; color:var(--accent); font-weight:700; }

  #previewContainer{ display:flex; justify-content:center; align-items:center; }

  @media (max-width:600px){
    body{ padding:0.5rem; }
    textarea{ height:180px; font-size:0.95rem; }
    .controls{ justify-content:space-between; }
    .controls button{ flex:1 1 45%; padding:0.5rem; font-size:0.9rem; }
  }

.number-input {
  display: inline-flex;
  align-items: center;
  background: #333;
  border-radius: 8px;
  overflow: hidden;
  width: 100px;
  height: 20px;
  margin-left: 8px;
}

.number-input button {
  background: #5cb9ff;
  color: white;
  border: none;
  width: 32px;
  height: 32px;
  font-size: 18px;
  cursor: pointer;
  transition: background 0.2s;
  line-height: 1;
}

.number-input button:hover {
  background: #3da8ff;
}

.number-input input[type=number] {
  border: none;
  text-align: center;
  width: 40px;
  font-size: 15px;
  background: #123456;
  color: #fff;
  outline: none;
  -moz-appearance: textfield;
}

/* hide browser arrows */
.number-input input::-webkit-outer-spin-button,
.number-input input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

@font-face{
  font-family:"MusicalSymbols";
  src:url(data:font/woff2;base64,${musicalB64}) format("woff2");
}

  /* large printable output area (like original) */
  #output{
    background:#fff;
    color:#000;
    box-shadow:0 0 10px rgba(0,0,0,0.3);
    border-radius:4px;
    transition:all .2s ease;
    aspect-ratio:8.5/11;
    width:100%;
    max-width:816px; /* 8.5in * 96dpi */
    overflow-y:auto;
    white-space:pre-wrap;
    line-height:1.6;
    box-sizing:border-box;
    /* default font will be overridden when we register fonts */
    font-family: "SabonNext", serif;
    letter-spacing: 0.3px;
    color:#000;
  }

  /* chord font for the highlighted tokens */
  #output strong{
    font-family: "KozukaGothic", sans-serif;
    letter-spacing: -0.5px;
    font-weight:400;
    color:#000;
    border-radius:4px;
    padding:0 2px;
  /*  letter-spacing: -0.5px; */
    vertical-align: baseline;
    transform: translateY(-0.5px);
  }

#output strong .repeatSymbol {
  font-family: inherit;
  font-size: 13pt;
  display: inline-block;
  transform: translateY(-1pt);
  margin: 0 2px;
  font-weight: 600;
}

  #output .chordLine {
    line-height: 1.5;          /* tighter spacing */
    margin-bottom: -0.25em;     /* brings lyrics closer */
    margin-top: 0.1em;         /* distance between combined lines (chords plus lyrics) */
    letter-spacing: -0.15px;     /* slightly tighter horizontally between chords */
  }

/* --- Chord element styling rules --- */
#output strong .chordRoot {
  font-size: 10.5pt;
  letter-spacing: 0em;
}

#output strong .chordSharp {
  font-size: 9pt;
  letter-spacing: -0.2em;
  margin-left: -2.6px;
}

#output strong .chordFlat {
  font-size: 9pt;
  letter-spacing: -0.23em;
  margin-left: -2.6px;
}

#output strong .chordMinor {
  font-size: 8pt;
}

#output strong .chord6,
#output strong .chord7,
#output strong .chord9 {
  font-size: 9pt;
  transform: translateY(-2.5pt);
  display: inline-block;
}

/* Generic number token style (default for numeric tokens like 7,9,13) */
#output strong .chordNum {
  font-size: 9pt;
  display: inline-block;
  /* individual tokens will use inline transform to alternate baseline shifts */
}

#output strong .chordDim {
  font-size: 11pt;
  transform: translateY(-1.5pt);
  display: inline-block;
}

#output strong .chordPlus {
  font-size: 8pt;
  transform: translateY(-4.5pt);
  display: inline-block;
}

#output strong .chordSus,
#output strong .chord2,
#output strong .chord4,
#output strong .chordM {
  font-size: 8pt;
  transform: translateY(-2.5pt);
  display: inline-block;
}

#output strong .chordSlash {
  font-size: 9pt;
  transform: translateY(-2.5pt);
  display: inline-block;
}

#output strong .bassNote {
  font-size: 9pt;
  transform: translateY(-2.5pt);
  display: inline-block;
}

#output strong .bassSharp {
  font-size: 9pt;
  letter-spacing: -0.16em;
  transform: translateY(-2.5pt);
  display: inline-block;
  margin-left: -2px;
}

#output strong .bassFlat {
  font-size: 9pt;
  letter-spacing: -0.24em;
  transform: translateY(-2.5pt);
  display: inline-block;
  margin-left: -2px;
}

#output strong .chordHalfDim {
  font-size: 10pt;
  letter-spacing: 0.03em;
  transform: translateY(-2.5pt);
  display: inline-block;
}

#output strong .chordAccExt {
  font-size: 9pt;
  letter-spacing: -0.2em; /* tweak as you like */
  display: inline-block;
}

#output strong .parenBlock {
  font-size: 9pt;
  transform: translateY(-2.5pt);
  display: inline-block;
}

</style>
</head>
<body>
  <h1>Transportador de Acordes para o Lulão</h1>
  <p>Ô, Lu, cola as cifras aí, meu</p>

  <input id="songTitle" type="text" placeholder="Título da canção..." oninput="updateOutput()" />
  <textarea id="input" placeholder="Cola as parada aqui..."></textarea>

  <div class="controls">
    <button onclick="transposeDown()" style="font-size:20px;">-</button>
    <button onclick="transposeUp()" style="font-size:20px;">+</button>
    <button id="toggleFlats" onclick="toggleFlats()">Muda pra ♭</button>
    <button onclick="exportTXT()">Salve como .TXT</button>
    <button onclick="exportPDF()">Salve como PDF</button>
    <button><a href="/chords/ocr.html" target="_blank" style="color:inherit; text-decoration:none; display:block;">Ferramenta OCR</a></button>
  </div>

  <details>
    <summary>Configurações</summary>
    <h3>Layout</h3>
    <div class="configs" style="margin-top:0.5rem;">

<label class="confs">
  Título:
  <div class="number-input">
    <button type="button" onclick="adjustValue('titleFontSize', -1)">−</button>
    <input
      type="number"
      id="titleFontSize"
      min="8"
      max="46"
      step="1"
      value="14"
    >
    <button type="button" onclick="adjustValue('titleFontSize', 1)">+</button>
  </div>
</label>

<label class="confs">
  Corpo:
  <div class="number-input">
    <button type="button" onclick="adjustValue('bodyFontSize', -1)">−</button>
    <input
      type="number"
      id="bodyFontSize"
      min="2"
      max="34"
      step="1"
      value="10"
    >
    <button type="button" onclick="adjustValue('bodyFontSize', 1)">+</button>
  </div>
</label>

<label class="confs">
  Margens:
  <div class="number-input">
    <button type="button" onclick="adjustValue('pdfMargin', -1)">−</button>
    <input
      type="number"
      id="pdfMargin"
      min="5"
      max="100"
      step="1"
      value="40"
    >
    <button type="button" onclick="adjustValue('pdfMargin', 1)">+</button>
  </div>
</label>

<hr>

<label class="confs">
  Detecção de Acordes (default 0.4):
  <div class="number-input">
    <button type="button" onclick="adjustValue('chordThreshold', -1)">−</button>
    <input
      type="number"
      id="chordThreshold"
      min="0"
      max="1"
      step="0.05"
      value="0.4"
    >
    <button type="button" onclick="adjustValue('chordThreshold', 1)">+</button>
  </div>
</label>

<hr>

<!-- 2 -->
<label class="confs">
  Espaços entre acordes:
  <div class="number-input">
    <button type="button" onclick="adjustValue('removeGlobal', -1)">−</button>
    <input
      type="number"
      id="removeGlobal"
      min="-10"
      max="10"
      step="1"
      value="2"
    >
    <button type="button" onclick="adjustValue('removeGlobal', 1)">+</button>
  </div>
</label>

<!-- 3 -->
<label class="confs">
  Remover espaços após ♯/♭:
  <div class="number-input">
    <button type="button" onclick="adjustValue('removeAcc', -1)">−</button>
    <input
      type="number"
      id="removeAcc"
      min="1"
      max="10"
      step="1"
      value="3"
    >
    <button type="button" onclick="adjustValue('removeAcc', 1)">+</button>
  </div>
</label>

<!-- 4 -->
<label class="confs">
  Adicionar espaços para acordes sem ♯/♭:
  <div class="number-input">
    <button type="button" onclick="adjustValue('addNonAcc', -1)">−</button>
    <input
      type="number"
      id="addNonAcc"
      min="0"
      max="10"
      step="1"
      value="2"
    >
    <button type="button" onclick="adjustValue('addNonAcc', 1)">+</button>
  </div>
</label>

<!-- 5 -->
<label class="confs">
  Tamanho dos acordes (chord scale):
  <div class="number-input">
    <button type="button" onclick="adjustValue('chordScale', -1)">−</button>
    <input
      type="number"
      id="chordScale"
      min="0.5"
      max="1.2"
      step="0.05"
      value="0.7"
    >
    <button type="button" onclick="adjustValue('chordScale', 1)">+</button>
  </div>
</label>

    </div>
  </details>

  <div id="previewContainer">
    <div id="output"></div>
  </div>

<script>
function adjustValue(id, direction) {
  const input = document.getElementById(id);
  const step = parseFloat(input.step) || 1;
  const min = parseFloat(input.min);
  const max = parseFloat(input.max);
  let value = parseFloat(input.value) || 0;

  value += direction * step;
  value = Math.min(Math.max(value, min), max);
  value = Number(value.toFixed(3)); // prevents floating rounding errors

  input.value = value;
  input.dispatchEvent(new Event('input'));
}
</script>

<script>
/* ----- constants/state ----- */
const NOTES_SHARP = ["C","C♯","D","D♯","E","F","F♯","G","G♯","A","A♯","B"];
const NOTES_FLAT  = ["C","D♭","D","E♭","E","F","G♭","G","A♭","A","B♭","B"];
let useFlatsDisplay = false;
let currentTranspose = 0;
let chordThreshold = 0.4;

let prevTranspose = 0;
let prevUseFlatsDisplay = false;

/* const CHORD_REGEX = /\b([A-G](?:♯|♭)?)([^\s]*)/g; */
const CHORD_REGEX = /(?:\b[A-G](?:♯|♭)?[^\s]*)|(?:\/[A-G](?:♯|♭)?)|(?:\b(?:sus|add|dim|aug|maj|m|M)\d*\b)|(?:\([^)]+\))/g;


/* ----- proportional font ratios ----- */
const SABON_SIZE_RATIO = 1;              // base
const KOZUKA_SIZE_RATIO = 10.5 / 11;     // 0.9545
const SABON_LINE_RATIO = 12 / 11;        // 1.0909
const KOZUKA_LINE_RATIO = 12.6 / 10.5;   // 1.2

/* ----- font helpers ----- */
async function loadArrayBufferAsBase64(path) {
  const res = await fetch(path);
  if (!res.ok) throw new Error("Font not found: " + path);
  const buf = await res.arrayBuffer();
  let binary = "";
  const bytes = new Uint8Array(buf);
  const chunk = 0x8000;
  for (let i = 0; i < bytes.length; i += chunk) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
  }
  return btoa(binary);
}

async function registerFontsForBrowser() {
  if (document.getElementById("font-injected")) return;

  try {
    // Load fonts (WOFF2 preferred, fallback to TTF)
    const [kozukaB64, sabonB64, musicalB64] = await Promise.all([
      loadArrayBufferAsBase64("Kozuka Gothic Pr6N R.otf"),
      loadArrayBufferAsBase64("SabonNext LT-Regular.otf"),
      loadArrayBufferAsBase64("MUSICAL.woff2").catch(() =>
        loadArrayBufferAsBase64("MUSICAL.TTF")
      )
    ]);

    const css = `
      @font-face {
        font-family: "KozukaGothic";
        src: url(data:font/otf;base64,${kozukaB64}) format("opentype");
        font-weight: 400; font-style: normal;
      }
      @font-face {
        font-family: "SabonNext";
        src: url(data:font/otf;base64,${sabonB64}) format("opentype");
        font-weight: 400; font-style: normal;
      }
      @font-face {
        font-family: "MusicalSymbols";
        src: url(data:font/woff2;base64,${musicalB64}) format("woff2"),
             url(data:font/ttf;base64,${musicalB64}) format("truetype");
        font-weight: 400; font-style: normal;
      }

      #output strong {
        font-family: "KozukaGothic", sans-serif;
        font-weight: 400;
        color: #000;
        border-radius: 4px;
        padding: 0 0.2px;
        letter-spacing: -0.5px;
        vertical-align: baseline;
        transform: translateY(-0.5px);
      }

      /* Repeat symbol with safe fallback fonts */
      #output strong .repeatSymbol {
        font-family: "MusicalSymbols","Noto Music","Segoe UI Symbol","Arial Unicode MS",sans-serif;
        display: inline-block;
        font-size: 11pt;
        transform: translateY(-1pt);
        margin: 0 2px;
      }
    `;

    const style = document.createElement("style");
    style.id = "font-injected";
    style.appendChild(document.createTextNode(css));
    document.head.appendChild(style);

    // Preload fonts
    await Promise.all([
      document.fonts.load('10.5pt "KozukaGothic"'),
      document.fonts.load('11pt "SabonNext"'),
      document.fonts.load('11pt "MusicalSymbols"')
    ]);

    // ✅ Runtime fallback check: replace bad glyphs
    setTimeout(() => {
      document.querySelectorAll('#output .repeatSymbol').forEach(el => {
        const text = el.textContent.trim();
        // detect if glyph failed to render (shows blank or tofu box)
        if (!text || text === "�" || el.offsetWidth < 4) {
          el.textContent = "%"; // fallback to plain %
          el.style.fontFamily = 'inherit';
        }
      });
    }, 500);

  } catch (err) {
    console.warn("⚠️ Could not load fonts for preview:", err);
    // fallback if everything fails
    document.querySelectorAll('#output .repeatSymbol').forEach(el => {
      el.textContent = "%";
      el.style.fontFamily = 'inherit';
    });
  }
}

/* ----- transpose/highlight logic ----- */
function transposeNote(note, steps, flats = useFlatsDisplay) {
  const idxSharp = NOTES_SHARP.indexOf(note);
  const idxFlat  = NOTES_FLAT.indexOf(note);
  const idx = idxSharp !== -1 ? idxSharp : idxFlat;
  if (idx === -1) return note;
  const newSharp = NOTES_SHARP[(idx + steps + 12) % 12];
  const newFlat  = NOTES_FLAT[(idx + steps + 12) % 12];
  return flats ? newFlat : newSharp;
}

function transposeChord(chord, steps, flats = useFlatsDisplay) {
  return chord.replace(/^([A-G](?:♯|♭)?)(.*)$/, (_, root, rest) => {
    const newRoot = transposeNote(root, steps, flats);
    const slashMatch = rest.match(/\/([A-G](?:♯|♭)?)(?!\d)/);
    if (slashMatch) {
      const bass = slashMatch[1];
      const transposedBass = transposeNote(bass, steps, flats);
      rest = rest.replace("/" + bass, "/" + transposedBass);
    }
    return newRoot + rest;
  });
}

function transposeText(text, steps, flats = useFlatsDisplay) {
  return text.replace(CHORD_REGEX, chord => transposeChord(chord, steps, flats));
}

function highlightChords(text) {
    // ✅ Normalize any private-use glyphs (U+F0D4 etc.) to plain %
  text = text.replace(/[\uF0D4\uF0D5\uF0D6\uF0D7\uF0D8\uF0D9\uF0DA\uF0DB\uF0DC\uF0DD\uF0DE\uF0DF\uF0E0]/g, "%");

  return text.replace(CHORD_REGEX, match => {
    // Detect if token looks like a normal chord (starts with A–G)
    const isNormalChord = /^[A-G]/.test(match);

    // For non-root tokens (sus2, /A, etc.), wrap everything raised + smaller
    if (!isNormalChord) {
      return `<strong><span class="chordRoot" style="font-size:9pt; transform:translateY(-2.5pt); display:inline-block;">${match}</span></strong>`;
    }

    // Normal chord parsing
    const m = match.match(/^([A-G])([♯♭]?)(.*)$/);
    if (!m) return match;

    const [, root, accidental, restRaw] = m;
    let html = `<span class="chordRoot">${root}</span>`;
    if (accidental) {
      html += `<span class="${accidental === "♯" ? "chordSharp" : "chordFlat"}">${accidental}</span>`;
    }

    let remaining = restRaw;
    let numIndex = 0;
    let insideParens = false;

    while (remaining.length > 0) {
      // 1) parentheses
      if (remaining[0] === "(") {
        html += `<span class="parenBlock">(</span>`;
        insideParens = true;
        remaining = remaining.slice(1);
        continue;
      }
      if (remaining[0] === ")") {
        html += `<span class="parenBlock">)</span>`;
        insideParens = false;
        remaining = remaining.slice(1);
        continue;
      }

      // 2) slash bass
      const slashMatch = remaining.match(/^\/([A-G])([♯♭]?)/);
      if (slashMatch) {
        const [, bassRoot, bassAcc] = slashMatch;
        const raise = "translateY(-2.5pt)";
        html += `<span class="chordSlash" style="${raise}">/</span><span class="bassNote" style="${raise}">${bassRoot}</span>`;
        if (bassAcc) {
          html += `<span class="${bassAcc === "♯" ? "bassSharp" : "bassFlat"}" style="${raise}">${bassAcc}</span>`;
        }
        remaining = remaining.slice(slashMatch[0].length);
        continue;
      }

      // 3) keywords
      const wordMatch = remaining.match(/^(dim|sus|M|m|\+|ø)/i);
      if (wordMatch) {
        const token = wordMatch[1];
        const cls =
          token.toLowerCase() === "dim" ? "chordDim" :
          token === "+" ? "chordPlus" :
          token.toLowerCase() === "sus" ? "chordSus" :
          token === "M" ? "chordM" :
          token === "m" ? "chordMinor" :
          token === "ø" ? "chordHalfDim" : "";
        html += `<span class="${cls}">${token}</span>`;
        remaining = remaining.slice(token.length);
        continue;
      }

      // 4) sus2/sus4 numbers after "sus"
      const susNumMatch = remaining.match(/^(2|4|5)(?!\d)/);
      if (susNumMatch && /sus$/i.test(html)) {
        const token = susNumMatch[1];
        html += `<span class="chordSus" style="transform:translateY(-2.5pt);">${token}</span>`;
        remaining = remaining.slice(token.length);
        continue;
      }

      // 5) extension accidentals (#/b)
      const accExtMatch = remaining.match(/^([♯♭])/);
      if (accExtMatch) {
        const sym = accExtMatch[1];
        html += `<span class="chordAccExt">${sym}</span>`;
        remaining = remaining.slice(1);
        continue;
      }

      // 6) number tokens (with optional accidentals)
      const accNumMatch = remaining.match(/^([b#♭♯])(\d{1,2})/);
      if (accNumMatch) {
        const [, sign, digits] = accNumMatch;
        const token = sign + digits;
        const shift = (insideParens || numIndex % 2 === 0) ? "translateY(-2.5pt)" : "translateY(0)";
        html += `<span class="chordNum" style="transform:${shift};">${token}</span>`;
        numIndex++;
        remaining = remaining.slice(token.length);
        continue;
      }

      if (/^\d/.test(remaining)) {
        const token = (remaining.length >= 2 && remaining[0] === "1" && /[0-3]/.test(remaining[1]))
          ? remaining.slice(0, 2)
          : remaining[0];
        const shift = (insideParens || numIndex % 2 === 0)
          ? "translateY(-2.5pt)" : "translateY(0)";
        html += `<span class="chordNum" style="transform:${shift};">${token}</span>`;
        numIndex++;
        remaining = remaining.slice(token.length);
        continue;
      }

// ✅ normalize any private-use or broken repeat glyphs to plain %
if (remaining.length && remaining.codePointAt(0) === 0xF0D4) {
  html += `<span class="repeatSymbol">%</span>`;
  remaining = remaining.slice(1);
  continue;
}
if (remaining[0] === "" || remaining[0] === "%") {
  html += `<span class="repeatSymbol">%</span>`;
  remaining = remaining.slice(1);
  continue;
}

// also handle whole-token repeats like % or ||: :||
if (
  match === "||:" ||
  match === ":||" ||
  match.trim() === "%" ||
  (match.length === 1 && match.codePointAt(0) === 0xF0D4)
) {
  return `<strong><span class="repeatSymbol">%</span></strong>`;
}


     // 7) normal fallback char
      html += remaining[0];
      remaining = remaining.slice(1);
    }

    return `<strong>${html}</strong>`;
  });
}


/* ----- NEW: spacing adjuster (adds/removes 2 spaces) ----- */
function adjustChordSpacingByAccidentals(line, steps, flats) {
  // --- CONFIGURATION ---
  const REMOVE_COUNT_GLOBAL = parseInt(document.getElementById("removeGlobal")?.value || 2, 10);
  const REMOVE_FOR_ACC       = parseInt(document.getElementById("removeAcc")?.value || 3, 10);
  const ADD_FOR_NONACC       = parseInt(document.getElementById("addNonAcc")?.value || 2, 10);
  const MIN_SPACES = 1;
  const TAB_WIDTH = 4;

  // normalize tabs
  const normalizedLine = line.replace(/\t/g, " ".repeat(TAB_WIDTH));

  return normalizedLine.replace(/([A-G](?:♯|♭|#|b)?[^\s]*)(\s*)/g, (m, token, space) => {
    // transpose as usual
    const transposed = transposeChord(token, steps, flats);

    // ✅ Detect any accidental (root, middle, or bass note)
    // includes visual ♯♭ and ASCII #/b
    const hasAcc = /[♯♭]/.test(transposed);

    // normalize spaces
    let spaces = space || " ";
    spaces = " ".repeat(Math.max(1, spaces.length));

    // --- PART 1: Accidental-based adjustment ---
    if (hasAcc) {
      // tighter for chords with ♯/♭
      spaces = spaces.length > REMOVE_FOR_ACC ? spaces.slice(0, -REMOVE_FOR_ACC) : " ".repeat(MIN_SPACES);
    } else {
      // slightly looser for plain chords
      spaces += " ".repeat(ADD_FOR_NONACC);
    }

    // --- PART 2: Global tightening rule ---
    const finalLen = Math.max(MIN_SPACES, spaces.length + REMOVE_COUNT_GLOBAL);
    const adjustedSpaces = " ".repeat(finalLen);

    return transposed + adjustedSpaces;
  });
}

/* ----- UI update ----- */
const DPI = 96;
const PT_TO_PX = DPI / 72;
function ptToPx(pt){ return pt * PT_TO_PX; }

async function updateOutput() {
// ensure no leftover U+F0D4 in user input
  const inputEl = document.getElementById("input");
  inputEl.value = inputEl.value.replace(/\uF0D4/g, "%");

  await registerFontsForBrowser();
  const title = document.getElementById("songTitle").value.trim();
  const input = document.getElementById("input").value || "";
  const lines = input.split(/\n/);

  // Parse and highlight chords line-by-line
  const out = lines.map(line => {
    const tokens = line.trim().split(/\s+/);
    if (!tokens.length) return line;
    const chordCount = tokens.filter(w => /^[A-G](?:♯|♭)?/.test(w)).length;

    if (chordCount / tokens.length >= chordThreshold) {
      const adjusted = adjustChordSpacingByAccidentals(line, currentTranspose, useFlatsDisplay);
      return `<div class="chordLine">${highlightChords(adjusted)}</div>`;
    }
    return `<div>${line}</div>`;
  }).join("");

  // Configs and conversions
  const titleFontSizePt = parseFloat(document.getElementById("titleFontSize").value || 14);
  const bodyFontSizePt  = parseFloat(document.getElementById("bodyFontSize").value || 10);
  const marginPt = parseFloat(document.getElementById("pdfMargin").value || 40);
  const titleFontSizePx = ptToPx(titleFontSizePt);
  const bodyFontSizePx = ptToPx(bodyFontSizePt);
  const marginPx = ptToPx(marginPt);
  const printableWidthPx = 8.5 * DPI - marginPx * 2;

  // Build HTML
  const titleHTML = title
    ? `<div style="text-align:center;color:#000;margin-top:0;font-size:${titleFontSizePx}px;font-weight:700">${escapeHtml(title)}</div>\n`
    : "";

  const outputDiv = document.getElementById("output");
  outputDiv.innerHTML = titleHTML + out;

  // --- Apply base layout font ---
  outputDiv.style.fontFamily = '"SabonNext", serif';
  outputDiv.style.fontSize = (bodyFontSizePx * SABON_SIZE_RATIO) + "px";
  outputDiv.style.lineHeight = SABON_LINE_RATIO;
  outputDiv.style.width = printableWidthPx + "px";
  outputDiv.style.padding = marginPx + "px";

  // --- Apply main chord font ---
  document.querySelectorAll('#output strong').forEach(el => {
    el.style.fontFamily = '"KozukaGothic", sans-serif';
    el.style.fontSize = (bodyFontSizePx * KOZUKA_SIZE_RATIO) + "px";
    el.style.lineHeight = KOZUKA_LINE_RATIO;
  });

  // ✅ --- NEW: calibrated scaling for all chord components ---
  const baseBody = 10; // your default CSS baseline for lyric size
  const chordScaleFactor = parseFloat(document.getElementById("chordScale")?.value || 0.7);
  const chordScale = (bodyFontSizePt / baseBody) * KOZUKA_SIZE_RATIO * chordScaleFactor;

  document.querySelectorAll('#output strong span').forEach(span => {
    const css = window.getComputedStyle(span);
    const currentPt = parseFloat(css.fontSize);
    if (!isNaN(currentPt)) {
      span.style.fontSize = (currentPt * chordScale) + "pt";
    }
  });

// normalize any remaining private-use glyphs just in case
document.querySelectorAll('#output .repeatSymbol').forEach(el => {
  if (el.textContent && el.textContent.codePointAt(0) === 0xF0D4) {
    el.textContent = "%";
    el.style.fontFamily = "inherit";
  }
});

  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;
}

/* escape helper */
function escapeHtml(s){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

/* ----- controls ----- */
function transposeUp(){
  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;
  currentTranspose++;
  updateOutput();
}
function transposeDown(){
  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;
  currentTranspose--;
  updateOutput();
}
function toggleFlats(){
  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;
  useFlatsDisplay = !useFlatsDisplay;
  document.getElementById("toggleFlats").textContent = useFlatsDisplay ? "Muda pra ♯" : "Muda pra ♭";
  updateOutput();
}

/* ----- settings persistence ----- */
function saveSettings(){
  const settings = {
    titleFontSize: document.getElementById("titleFontSize").value,
    bodyFontSize: document.getElementById("bodyFontSize").value,
    pdfMargin: document.getElementById("pdfMargin").value,
    chordThreshold: document.getElementById("chordThreshold").value,
    removeGlobal: document.getElementById("removeGlobal").value,
    removeAcc: document.getElementById("removeAcc").value,
    chordScale: document.getElementById("chordScale").value,
    addNonAcc: document.getElementById("addNonAcc").value
  };
  localStorage.setItem("transposerSettings", JSON.stringify(settings));
}

function loadSettings(){
  const s = JSON.parse(localStorage.getItem("transposerSettings") || "{}");
  if (s.titleFontSize) document.getElementById("titleFontSize").value = s.titleFontSize;
  if (s.bodyFontSize) document.getElementById("bodyFontSize").value = s.bodyFontSize;
  if (s.pdfMargin) document.getElementById("pdfMargin").value = s.pdfMargin;
  if (s.chordThreshold !== undefined){
    document.getElementById("chordThreshold").value = s.chordThreshold;
    document.getElementById("thresholdVal").textContent = s.chordThreshold;
    chordThreshold = parseFloat(s.chordThreshold);
  }
  if (s.removeGlobal) {
  document.getElementById("removeGlobal").value = s.removeGlobal;
  document.getElementById("removeGlobalVal").textContent = s.removeGlobal;
}
if (s.removeAcc) {
  document.getElementById("removeAcc").value = s.removeAcc;
  document.getElementById("removeAccVal").textContent = s.removeAcc;
}
if (s.chordScale) {
  document.getElementById("chordScale").value = s.chordScale;
  document.getElementById("chordScaleVal").textContent = s.chordScale;
}
if (s.addNonAcc) {
  document.getElementById("addNonAcc").value = s.addNonAcc;
  document.getElementById("addNonAccVal").textContent = s.addNonAcc;
}
}

/* wire up inputs */
document.querySelectorAll("#titleFontSize,#bodyFontSize,#pdfMargin,#removeGlobal,#removeAcc,#addNonAcc,#chordScale").forEach(el=>{
  el.addEventListener("input", ()=>{ saveSettings(); updateOutput(); });
});
document.getElementById("chordThreshold").addEventListener("input", e=>{
  chordThreshold = parseFloat(e.target.value);
  document.getElementById("thresholdVal").textContent = e.target.value;
  saveSettings(); updateOutput();
});
document.getElementById("input").addEventListener("input", updateOutput);

/* init */
loadSettings();
registerFontsForBrowser().then(updateOutput).catch(()=>updateOutput());

/* ----- TXT export ----- */
function exportTXT(){
  const title = document.getElementById("songTitle").value.trim();
  const text = (title ? title + "\n\n" : "") + document.getElementById("output").innerText;
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "transposed_chords.txt";
  link.click();
}
</script>

<!-- jsPDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
async function exportPDF() {
  const { jsPDF } = window.jspdf;

  // Make sure fonts have loaded
  await document.fonts.ready;

  const pdf = new jsPDF({ orientation: "portrait", unit: "pt", format: "letter" });
  const margin = parseFloat(document.getElementById("pdfMargin").value || 40);
  const pageWidth = 8.5 * 72;
  const pageHeight = 11 * 72;
  const printableWidth = pageWidth - margin * 2;

  // Capture the output div exactly as shown
  const outputDiv = document.getElementById("output");
  const canvas = await html2canvas(outputDiv, {
    scale: 2,              // higher quality
    useCORS: true,
    backgroundColor: "#ffffff"
  });

  const imgData = canvas.toDataURL("image/png");

  // Compute scaling so it fits within page margins
  const imgWidth = printableWidth;
  const imgHeight = (canvas.height * imgWidth) / canvas.width;

  let y = margin;
  let x = margin;
  if (imgHeight > pageHeight - margin * 2) {
    // scale down if taller than page
    const scale = (pageHeight - margin * 2) / imgHeight;
    pdf.addImage(imgData, "PNG", x, y, imgWidth * scale, imgHeight * scale);
  } else {
    pdf.addImage(imgData, "PNG", x, y, imgWidth, imgHeight);
  }

  pdf.save("transposed_chords.pdf");
}
</script>

</body>
</html>

