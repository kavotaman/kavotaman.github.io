<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chord Transposer</title>
<link rel="icon" type="image/x-icon" href="/chords/favicon.png">

<style>
  :root{
    --accent:#5CB9FF;
    --bg:#2e2e2e;
    --text:#eaeaea;
  }

  /* page */
  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    max-width:900px;
    margin:2rem auto;
    padding:1rem;
    background:var(--bg);
    color:var(--text);
  }

  h1{ color:var(--accent); text-align:center; font-size:clamp(1.5rem,4vw,2.2rem); margin-bottom:0.5rem; }
  p{ color:var(--accent); text-align:center; margin-top:0; margin-bottom:1rem; }

  input[type="text"]{ width:96%; padding:0.5rem; margin:0 auto 1rem auto; display:block; font-size:1.1rem;
    border-radius:6px; border:1px solid #444; background:#1e1e1e; color:#e0e0e0; box-sizing:border-box;}
  textarea{ width:94%; min-height:220px; padding:0.75rem; margin:0 auto 1rem auto; display:block;
    border-radius:8px; border:1px solid #444; background:#1e1e1e; color:#e0e0e0; font-family:monospace; resize:vertical; box-sizing:border-box; }

  .controls{ display:flex; flex-wrap:wrap; gap:0.5rem; justify-content:center; margin-bottom:1rem; }
  .controls button{ flex:1 1 100px; background:#4da3ff; color:#fff; border:none; border-radius:8px; padding:0.6rem 1rem; cursor:pointer; }
  .controls button:hover{ background:#1e90ff; }

  .configs {
    font-size:16px;
  }

label {
  padding-left: 20px;
}

.confs {
  display: inline-block;
  margin-bottom: 5px;
}

.ajuste {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  font-weight: 400;
  color: #fff;
  background: #4da3ff;
  border: 1px solid #007bff;
  border-radius: 2px;
  width: 40px;
  height: 20px;
  text-align: center;
}

.ajuste1 {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  font-weight: 400;
  color: #fff;
  background: #4da300;
  border: 1px solid #007b00;
  border-radius: 2px;
  width: 40px;
  height: 20px;
  text-align: center;
}


  details{ margin-bottom:1rem; background:#1e1e1e; padding:1rem; border-radius:8px; }
  details summary{ cursor:pointer; color:var(--accent); font-weight:700; }

  #previewContainer{ display:flex; justify-content:center; align-items:center; }

  /* large printable output area (like original) */
  #output{
    background:#fff;
    color:#000;
    box-shadow:0 0 10px rgba(0,0,0,0.3);
    border-radius:4px;
    transition:all .2s ease;
    aspect-ratio:8.5/11;
    width:100%;
    max-width:816px; /* 8.5in * 96dpi */
    overflow-y:auto;
    white-space:pre-wrap;
    line-height:1.6;
    box-sizing:border-box;
    /* default font will be overridden when we register fonts */
    font-family: "SabonNext", serif;
    letter-spacing: 0.3px;
    color:#000;
  }

  /* chord font for the highlighted tokens */
  #output strong{
    font-family: "KozukaGothic", sans-serif;
    letter-spacing: -0.5px;
    font-weight:400;
    color:#000;
    border-radius:4px;
    padding:0 2px;
  /*  letter-spacing: -0.5px; */
    vertical-align: baseline;
    transform: translateY(-0.5px);
  }

  /* Accidentals get special kerning and closer alignment */
#output strong .accidental {
  display: inline-block;
  margin-left: -3.2px;   /* pulls it left toward chord root */
  margin-right: -1.2px;  /* pulls following characters closer */
  letter-spacing: -1px;  /* optional: tighten internal spacing of the glyph */
  transform: translateY(-0.5px); /* keeps ♯ and ♭ vertically centered nicely */
}

/* Only the chord root letters get full-width treatment */
#output strong .chordRoot {
  font-feature-settings: "fwid" 1;
  display: inline-block;
  letter-spacing: -2.5px;
}

  #output .chordLine {
    line-height: 1.5;          /* tighter spacing */
    margin-bottom: -0.25em;     /* brings lyrics closer */
    margin-top: 0.1em;         /* distance between combined lines (chords plus lyrics) */
    letter-spacing: -0.15px;     /* slightly tighter horizontally between chords */
  }

  @media (max-width:600px){
    body{ padding:0.5rem; }
    textarea{ height:180px; font-size:0.95rem; }
    .controls{ justify-content:space-between; }
    .controls button{ flex:1 1 45%; padding:0.5rem; font-size:0.9rem; }
  }

  .slidecontainer {
  width: 50%;
}

.slider1 {
  -webkit-appearance: none;
  width: 30%;
  height: 10px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.8;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider1:hover {
  opacity: 1;
}

.slider1::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 15px;
  background: #5cb900;
  cursor: pointer;
}

.slider1::-moz-range-thumb {
  width: 20px;
  height: 15px;
  background: #5cb900;
  cursor: pointer;
}

.slider {
  -webkit-appearance: none;
  width: 30%;
  height: 10px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.8;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 15px;
  background: #5cb9ff;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 20px;
  height: 15px;
  background: #5cb9ff;
  cursor: pointer;
}

</style>
</head>
<body>
  <h1>Transportador de Acordes para o Lulão</h1>
  <p>Ô, Lu, cola as cifras aí, meu</p>

  <input id="songTitle" type="text" placeholder="Título da canção..." oninput="updateOutput()" />
  <textarea id="input" placeholder="Cola as parada aqui..."></textarea>

  <div class="controls">
    <button onclick="transposeDown()" style="font-size:20px;">-</button>
    <button onclick="transposeUp()" style="font-size:20px;">+</button>
    <button id="toggleFlats" onclick="toggleFlats()">Muda pra ♭</button>
    <button onclick="exportTXT()">Salve como .TXT</button>
    <button onclick="exportPDF()">Salve como PDF</button>
    <button><a href="/chords/ocr.html" target="_blank" style="color:inherit; text-decoration:none; display:block;">Ferramenta OCR</a></button>
  </div>

  <details>
    <summary>Configurações</summary>
    <h3>Layout</h3>
    <div class="configs" style="margin-top:0.5rem;">
      <label class="confs">Tamanho do Título:
        <input type="number" id="titleFontSize" value="14" min="8" max="46" style="width:60px">
      </label><br/>
      <label class="confs">Tamanho do Resto:
        <input type="number" id="bodyFontSize" value="10" min="2" max="34" style="width:60px">
      </label><br/>
      <label class="confs">Margens (pt):
        <input type="number" id="pdfMargin" value="40" min="5" max="100" style="width:60px">
      </label><br/>
      <hr style="margin:0.8rem 0; border:none; border-top:1px solid #444;">

<h3>Avançadas</h3>

<label class="confs">
  Detecção de Acordes (default 0.4):
  <input
    type="range"
    class="slider1"
    id="chordThreshold"
    min="0"
    max="1"
    step="0.05"
    value="0.4"
    oninput="document.getElementById('thresholdVal').textContent=this.value"
  >
  <div class="ajuste1"><span id="thresholdVal">0.4</span></div>
</label>

<hr style="border:none; border-top:1px solid #444;">

<label class="confs">Espaços entre acordes:
<input
type="range"
    class="slider"
    id="removeGlobal"
    min="-10"
    max="10"
    step="1"
    value="2"
oninput="document.getElementById('removeGlobalVal').textContent=this.value"
    >
  <div class="ajuste"><span id="removeGlobalVal">2</span></div>
</label><br/>

<label class="confs">Remover espaços após ♯/♭:
<input
type="range"
    class="slider"
    id="removeAcc"
    min="1"
    max="10"
    step="1"
    value="3"
oninput="document.getElementById('removeAccVal').textContent=this.value"
    >
  <div class="ajuste"><span id="removeAccVal">3</span></div>
</label><br/>

<label class="confs">Adicionar espaços para acordes sem ♯/♭:
<input
type="range"
    class="slider"
    id="addNonAcc"
    min="0"
    max="10"
    step="1"
    value="2"
oninput="document.getElementById('addNonAccVal').textContent=this.value"
    >
  <div class="ajuste"><span id="addNonAccVal">2</span></div>
</label><br/>

    </div>
  </details>

  <div id="previewContainer">
    <div id="output"></div>
  </div>

<script>
/* ----- constants/state ----- */
const NOTES_SHARP = ["C","C♯","D","D♯","E","F","F♯","G","G♯","A","A♯","B"];
const NOTES_FLAT  = ["C","D♭","D","E♭","E","F","G♭","G","A♭","A","B♭","B"];
let useFlatsDisplay = false;
let currentTranspose = 0;
let chordThreshold = 0.4;

let prevTranspose = 0;
let prevUseFlatsDisplay = false;

const CHORD_REGEX = /\b([A-G](?:♯|♭)?)([^\s]*)/g;

/* ----- proportional font ratios ----- */
const SABON_SIZE_RATIO = 1;              // base
const KOZUKA_SIZE_RATIO = 10.5 / 11;     // 0.9545
const SABON_LINE_RATIO = 12 / 11;        // 1.0909
const KOZUKA_LINE_RATIO = 12.6 / 10.5;   // 1.2

/* ----- font helpers ----- */
async function loadArrayBufferAsBase64(path) {
  const res = await fetch(path);
  if (!res.ok) throw new Error("Font not found: " + path);
  const buf = await res.arrayBuffer();
  let binary = "";
  const bytes = new Uint8Array(buf);
  const chunk = 0x8000;
  for (let i = 0; i < bytes.length; i += chunk) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
  }
  return btoa(binary);
}

async function registerFontsForBrowser() {
  if (document.getElementById("font-injected")) return;
  try {
    const [kozukaB64, sabonB64] = await Promise.all([
      loadArrayBufferAsBase64("Kozuka Gothic Pr6N R.otf"),
      loadArrayBufferAsBase64("SabonNext LT-Regular.otf")
    ]);
    const css = `
      @font-face{ font-family:"KozukaGothic"; src: url(data:font/otf;base64,${kozukaB64}) format("opentype"); font-weight:400; font-style:normal; }
      @font-face{ font-family:"SabonNext"; src: url(data:font/otf;base64,${sabonB64}) format("opentype"); font-weight:400; font-style:normal; }
      #output strong {
        font-family: "KozukaGothic", sans-serif;
        font-weight:400;
        color:#000;
        border-radius:4px;
        padding:0 0.2px;
        letter-spacing:-0.5px;
        vertical-align:baseline;
        transform:translateY(-0.5px);
      }
    `;
    const s = document.createElement("style");
    s.id = "font-injected";
    s.appendChild(document.createTextNode(css));
    document.head.appendChild(s);
    await Promise.all([
      document.fonts.load('10.5pt "KozukaGothic"'),
      document.fonts.load('11pt "SabonNext"')
    ]);
  } catch (err) {
    console.warn("Could not load fonts for preview:", err);
  }
}

/* ----- transpose/highlight logic ----- */
function transposeNote(note, steps, flats = useFlatsDisplay) {
  const idxSharp = NOTES_SHARP.indexOf(note);
  const idxFlat  = NOTES_FLAT.indexOf(note);
  const idx = idxSharp !== -1 ? idxSharp : idxFlat;
  if (idx === -1) return note;
  const newSharp = NOTES_SHARP[(idx + steps + 12) % 12];
  const newFlat  = NOTES_FLAT[(idx + steps + 12) % 12];
  return flats ? newFlat : newSharp;
}

function transposeChord(chord, steps, flats = useFlatsDisplay) {
  return chord.replace(/^([A-G](?:♯|♭)?)(.*)$/, (_, root, rest) => {
    const newRoot = transposeNote(root, steps, flats);
    const slashMatch = rest.match(/\/([A-G](?:♯|♭)?)(?!\d)/);
    if (slashMatch) {
      const bass = slashMatch[1];
      const transposedBass = transposeNote(bass, steps, flats);
      rest = rest.replace("/" + bass, "/" + transposedBass);
    }
    return newRoot + rest;
  });
}

function transposeText(text, steps, flats = useFlatsDisplay) {
  return text.replace(CHORD_REGEX, chord => transposeChord(chord, steps, flats));
}

function highlightChords(text) {
  return text.replace(CHORD_REGEX, match => {
    // Split chord into root + rest
    const [, root, rest] = match.match(/^([A-G])(.*)$/) || ["", match, ""];
    const html = root
      ? `<span class="chordRoot">${root}</span>${rest.replace(/([♯♭])/g, '<span class="accidental">$1</span>')}`
      : match;
    return `<strong>${html}</strong>`;
  });
}

/* ----- NEW: spacing adjuster (adds/removes 2 spaces) ----- */
function adjustChordSpacingByAccidentals(line, steps, flats) {
  // --- CONFIGURATION ---
  const REMOVE_COUNT_GLOBAL = parseInt(document.getElementById("removeGlobal")?.value || 2, 10);
  const REMOVE_FOR_ACC       = parseInt(document.getElementById("removeAcc")?.value || 3, 10);
  const ADD_FOR_NONACC       = parseInt(document.getElementById("addNonAcc")?.value || 2, 10);
  const MIN_SPACES = 1;
  const TAB_WIDTH = 4;

  // normalize tabs
  const normalizedLine = line.replace(/\t/g, " ".repeat(TAB_WIDTH));

  return normalizedLine.replace(/([A-G](?:♯|♭|#|b)?[^\s]*)(\s*)/g, (m, token, space) => {
    // transpose as usual
    const transposed = transposeChord(token, steps, flats);

    // ✅ Detect any accidental (root, middle, or bass note)
    // includes visual ♯♭ and ASCII #/b
    const hasAcc = /[♯♭]/.test(transposed);

    // normalize spaces
    let spaces = space || " ";
    spaces = " ".repeat(Math.max(1, spaces.length));

    // --- PART 1: Accidental-based adjustment ---
    if (hasAcc) {
      // tighter for chords with ♯/♭
      spaces = spaces.length > REMOVE_FOR_ACC ? spaces.slice(0, -REMOVE_FOR_ACC) : " ".repeat(MIN_SPACES);
    } else {
      // slightly looser for plain chords
      spaces += " ".repeat(ADD_FOR_NONACC);
    }

    // --- PART 2: Global tightening rule ---
    const finalLen = Math.max(MIN_SPACES, spaces.length + REMOVE_COUNT_GLOBAL);
    const adjustedSpaces = " ".repeat(finalLen);

    return transposed + adjustedSpaces;
  });
}

/* ----- UI update ----- */
const DPI = 96;
const PT_TO_PX = DPI / 72;
function ptToPx(pt){ return pt * PT_TO_PX; }

async function updateOutput(){
  await registerFontsForBrowser();
  const title = document.getElementById("songTitle").value.trim();
  const input = document.getElementById("input").value || "";
  const lines = input.split(/\n/);

  const out = lines.map(line=>{
    const tokens = line.trim().split(/\s+/);
    if (!tokens.length) return line;
    const chordCount = tokens.filter(w => /^[A-G](?:♯|♭)?/.test(w)).length;

    if (chordCount / tokens.length >= chordThreshold) {
    // chord line → adjust spacing NEWNEW
    const adjusted = adjustChordSpacingByAccidentals(
     line,
     currentTranspose,
     useFlatsDisplay
   );

      // Mark chord lines
      return `<div class="chordLine">${highlightChords(adjusted)}</div>`;
    }
    return `<div>${line}</div>`;
  }).join("");

  const titleFontSizePt = parseFloat(document.getElementById("titleFontSize").value || 14);
  const bodyFontSizePt  = parseFloat(document.getElementById("bodyFontSize").value || 10);
  const marginPt = parseFloat(document.getElementById("pdfMargin").value || 40);
  const titleFontSizePx = ptToPx(titleFontSizePt);
  const bodyFontSizePx = ptToPx(bodyFontSizePt);
  const marginPx = ptToPx(marginPt);
  const printableWidthPx = 8.5 * DPI - marginPx * 2;

  const titleHTML = title
    ? `<div style="text-align:center;color:#000;margin-top:0;font-size:${titleFontSizePx}px;font-weight:700">${escapeHtml(title)}</div>\n`
    : "";

  const outputDiv = document.getElementById("output");
  outputDiv.innerHTML = titleHTML + out;

  // Apply proportional font relationships
  outputDiv.style.fontFamily = '"SabonNext", serif';
  outputDiv.style.fontSize = (bodyFontSizePx * SABON_SIZE_RATIO) + "px";
  outputDiv.style.lineHeight = SABON_LINE_RATIO;
  outputDiv.style.width = printableWidthPx + "px";
  outputDiv.style.padding = marginPx + "px";

  // adjust chord font separately
  document.querySelectorAll('#output strong').forEach(el=>{
    el.style.fontFamily = '"KozukaGothic", sans-serif';
    el.style.fontSize = (bodyFontSizePx * KOZUKA_SIZE_RATIO) + "px";
    el.style.lineHeight = KOZUKA_LINE_RATIO;
  });
  
  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;

}

/* escape helper */
function escapeHtml(s){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

/* ----- controls ----- */
function transposeUp(){
  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;
  currentTranspose++;
  updateOutput();
}
function transposeDown(){
  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;
  currentTranspose--;
  updateOutput();
}
function toggleFlats(){
  prevTranspose = currentTranspose;
  prevUseFlatsDisplay = useFlatsDisplay;
  useFlatsDisplay = !useFlatsDisplay;
  document.getElementById("toggleFlats").textContent = useFlatsDisplay ? "Muda pra ♯" : "Muda pra ♭";
  updateOutput();
}

/* ----- settings persistence ----- */
function saveSettings(){
  const settings = {
    titleFontSize: document.getElementById("titleFontSize").value,
    bodyFontSize: document.getElementById("bodyFontSize").value,
    pdfMargin: document.getElementById("pdfMargin").value,
    chordThreshold: document.getElementById("chordThreshold").value,
    removeGlobal: document.getElementById("removeGlobal").value,
    removeAcc: document.getElementById("removeAcc").value,
    addNonAcc: document.getElementById("addNonAcc").value
  };
  localStorage.setItem("transposerSettings", JSON.stringify(settings));
}

function loadSettings(){
  const s = JSON.parse(localStorage.getItem("transposerSettings") || "{}");
  if (s.titleFontSize) document.getElementById("titleFontSize").value = s.titleFontSize;
  if (s.bodyFontSize) document.getElementById("bodyFontSize").value = s.bodyFontSize;
  if (s.pdfMargin) document.getElementById("pdfMargin").value = s.pdfMargin;
  if (s.chordThreshold !== undefined){
    document.getElementById("chordThreshold").value = s.chordThreshold;
    document.getElementById("thresholdVal").textContent = s.chordThreshold;
    chordThreshold = parseFloat(s.chordThreshold);
  }
  if (s.removeGlobal) {
  document.getElementById("removeGlobal").value = s.removeGlobal;
  document.getElementById("removeGlobalVal").textContent = s.removeGlobal;
}
if (s.removeAcc) {
  document.getElementById("removeAcc").value = s.removeAcc;
  document.getElementById("removeAccVal").textContent = s.removeAcc;
}
if (s.addNonAcc) {
  document.getElementById("addNonAcc").value = s.addNonAcc;
  document.getElementById("addNonAccVal").textContent = s.addNonAcc;
}
}

/* wire up inputs */
document.querySelectorAll("#titleFontSize,#bodyFontSize,#pdfMargin,#removeGlobal,#removeAcc,#addNonAcc").forEach(el=>{
  el.addEventListener("input", ()=>{ saveSettings(); updateOutput(); });
});
document.getElementById("chordThreshold").addEventListener("input", e=>{
  chordThreshold = parseFloat(e.target.value);
  document.getElementById("thresholdVal").textContent = e.target.value;
  saveSettings(); updateOutput();
});
document.getElementById("input").addEventListener("input", updateOutput);

/* init */
loadSettings();
registerFontsForBrowser().then(updateOutput).catch(()=>updateOutput());

/* ----- TXT export ----- */
function exportTXT(){
  const title = document.getElementById("songTitle").value.trim();
  const text = (title ? title + "\n\n" : "") + document.getElementById("output").innerText;
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "transposed_chords.txt";
  link.click();
}
</script>

<!-- jsPDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
async function exportPDF() {
  const { jsPDF } = window.jspdf;

  // Make sure fonts have loaded
  await document.fonts.ready;

  const pdf = new jsPDF({ orientation: "portrait", unit: "pt", format: "letter" });
  const margin = parseFloat(document.getElementById("pdfMargin").value || 40);
  const pageWidth = 8.5 * 72;
  const pageHeight = 11 * 72;
  const printableWidth = pageWidth - margin * 2;

  // Capture the output div exactly as shown
  const outputDiv = document.getElementById("output");
  const canvas = await html2canvas(outputDiv, {
    scale: 2,              // higher quality
    useCORS: true,
    backgroundColor: "#ffffff"
  });

  const imgData = canvas.toDataURL("image/png");

  // Compute scaling so it fits within page margins
  const imgWidth = printableWidth;
  const imgHeight = (canvas.height * imgWidth) / canvas.width;

  let y = margin;
  let x = margin;
  if (imgHeight > pageHeight - margin * 2) {
    // scale down if taller than page
    const scale = (pageHeight - margin * 2) / imgHeight;
    pdf.addImage(imgData, "PNG", x, y, imgWidth * scale, imgHeight * scale);
  } else {
    pdf.addImage(imgData, "PNG", x, y, imgWidth, imgHeight);
  }

  pdf.save("transposed_chords.pdf");
}
</script>

</body>
</html>

