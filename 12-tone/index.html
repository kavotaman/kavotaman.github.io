<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>12-Tone Row Analyzer</title>
  <link rel="icon" type="image/x-icon" href="/12-tone/favicon.png">
  <meta name="viewport" content="width=device-width,initial-scale=1" />

<style>
  :root{
    --bg:#0f172a;        /* page background */
    --card:#020617;     /* main card background */
    --panel:#020617;    /* inner cards */
    --border:#1e293b;   /* borders */
    --text:#e5e7eb;     /* main text */
    --muted:#94a3b8;    /* secondary text */
    --accent:#3b82f6;   /* primary button */
    --accent-hover:#2563eb;
    --error-bg:#450a0a;
    --error-border:#7f1d1d;
    --error-text:#fecaca;
  }

  body{
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
    background:var(--bg);
    color:var(--text);
    margin:0;
    padding:24px;
  }

  .app{
    max-width:980px;
    margin:0 auto;
    background:var(--card);
    border-radius:14px;
    box-shadow:0 10px 30px rgba(0,0,0,.45);
    padding:20px;
    border:1px solid var(--border);
  }

  h1{margin:0 0 6px;font-size:20px;color:#f8fafc}
  h3{margin:0 0 8px;font-size:15px;color:#f1f5f9}

  p.sub{margin:0 0 16px;color:var(--muted)}

  textarea{
    width:100%;
    min-height:56px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
    font-size:14px;
    padding:10px;
    border-radius:8px;
    border:1px solid var(--border);
    background:#020617;
    color:var(--text);
    box-sizing:border-box;
  }

  textarea:focus{
    outline:none;
    border-color:var(--accent);
  }

  .controls{
    display:flex;
    gap:8px;
    margin:12px 0;
  }

  button{
    border-radius:999px;
    border:1px solid var(--border);
    padding:8px 12px;
    background:#020617;
    color:var(--text);
    cursor:pointer;
  }

  button:hover{
    background:#020617;
    border-color:var(--accent);
    color:#dbeafe;
  }

  button.primary{
    background:var(--accent);
    color:#fff;
    border-color:var(--accent);
  }

  button.primary:hover{
    background:var(--accent-hover);
  }

  .error{
    background:var(--error-bg);
    border:1px solid var(--error-border);
    color:var(--error-text);
    padding:10px;
    border-radius:8px;
    margin:8px 0;
    white-space:pre-wrap;
  }

  .grid{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
    gap:12px;
  }

  .card{
    background:var(--panel);
    border:1px solid var(--border);
    padding:12px;
    border-radius:10px;
  }

  .mono{
    font-family:ui-monospace,monospace;
    font-size:13px;
    white-space:pre-wrap;
    color:#f8fafc;
  }

  .muted{
    color:var(--muted);
    font-size:13px;
  }

  .small{
    font-size:13px;
    color:var(--muted);
  }

  hr.sep{
    border:none;
    border-top:1px solid var(--border);
    margin:10px 0;
  }
</style>

</head>
<body>
  <div class="app">
    <h1>12-Tone Row Analyzer</h1>
    <p class="sub">Accepts enharmonic spellings (A# = Bb, etc). Splits into trichords (4×3) and tetrachords (3×4), computes prime forms and reports derivation. Paste a 12-tone row and click Analyze.</p>

    <textarea id="rowInput">G F# A G# C C# A# B D# D F E</textarea>

    <div class="controls">
      <button class="primary" onclick="runAnalysis()">Analyze</button>
      <button onclick="resetExample()">Reset example</button>
      <button onclick="copyResults()">Copy OCPI/IC</button>
    </div>

    <div id="errorBox" class="error" style="display:none"></div>

    <div id="results" style="display:none">
      <div class="grid">
        <div class="card">
          <h3>Pitch-classes</h3>
          <div id="pcNums" class="mono"></div>
          <div id="pcNames" class="muted"></div>
        </div>

        <div class="card">
          <h3>OCPI (ordered pitch-class intervals)</h3>
          <div id="ocpi" class="mono"></div>
          <div id="ocpiPal" class="small muted"></div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <h3>IC (interval classes)</h3>
        <div id="ic" class="mono"></div>
        <div id="icPal" class="small muted"></div>
      </div>

      <div class="card" style="margin-top:12px">
        <h3>Trichords — raw and prime forms</h3>
        <div id="triSets" class="mono" style="margin-bottom:8px"></div>
        <div id="triResult" class="small"></div>

        <hr class="sep" />

        <h3>Tetrachords — raw and prime forms</h3>
        <div id="tetSets" class="mono" style="margin-bottom:8px"></div>
        <div id="tetResult" class="small"></div>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
   Note maps (enharmonic-safe)
   --------------------------- */
const NOTE_TO_PC = {
  C:0,"B#":0,
  "C#":1,Db:1,
  D:2,"D#":3,Eb:3,
  E:4,Fb:4,"E#":5,F:5,
  "F#":6,Gb:6,
  G:7,"G#":8,Ab:8,
  A:9,"A#":10,Bb:10,
  B:11,Cb:11
};
const PC_TO_NOTE = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

/* Normalize token: uppercase only letter, keep accidental */
function normalizeToken(token){
  if(!token) return token;
  token = token.replace(/\u266F/g,'#').replace(/\u266D/g,'b'); // ♯ ♭
  token = token.trim();
  if(token.length === 1) return token[0].toUpperCase();
  // first char uppercase, rest left as-is (so 'bb' -> 'b' is not produced)
  return token[0].toUpperCase() + token.slice(1);
}

function parseRow(text){
  // split by commas/spaces/newlines/tabs/semicolons
  const tokens = text.replace(/[\u2018\u2019\u201c\u201d]/g,'').split(/[ ,;\\t\\n]+/).filter(Boolean);
  const pcs = [], bad = [];
  for(let t of tokens){
    const norm = normalizeToken(t);
    if(Object.prototype.hasOwnProperty.call(NOTE_TO_PC, norm)) pcs.push(NOTE_TO_PC[norm]);
    else bad.push(t);
  }
  return {pcs,bad};
}

/* ---------------------------
   Intervals (OCPI / IC)
   --------------------------- */
function ocpiSequence(pcs){ const seq=[]; for(let i=0;i<pcs.length-1;i++) seq.push((pcs[i+1]-pcs[i]+12)%12); return seq; }
function icSequence(pcs){ return ocpiSequence(pcs).map(d => Math.min(d,(12-d)%12)); }
function isPalindrome(arr){ for(let i=0;i<Math.floor(arr.length/2); i++) if(arr[i] !== arr[arr.length-1-i]) return false; return true; }

/* ---------------------------
   Prime form utilities
   --------------------------- */
function mod(n,m=12){ return ((n % m) + m) % m; }
function uniqueSorted(set){ return Array.from(new Set(set)).sort((a,b)=>a-b); }

function normalOrder(set){
  const u = uniqueSorted(set);
  if(u.length === 0) return [];
  // build rotations and choose minimal span; tiebreak lexicographically
  let best = null;
  for(let i=0;i<u.length;i++){
    const rot = u.slice(i).concat(u.slice(0,i).map(x => x + 12));
    const span = rot[rot.length-1] - rot[0];
    if(best === null){ best = rot; continue; }
    const bestSpan = best[best.length-1] - best[0];
    if(span < bestSpan) best = rot;
    else if(span === bestSpan){
      // lex tiebreak (compare elements in order)
      for(let j=0;j<rot.length;j++){
        const rVal = rot[j];
        const bVal = best[j] !== undefined ? best[j] : Infinity;
        if(rVal < bVal){ best = rot; break; }
        if(rVal > bVal) break;
      }
    }
  }
  return best.map(x => mod(x));
}

function invertSet(set){ return set.map(x => mod(12 - x)); }
function transposeToZero(set){ const t = set[0] || 0; return set.map(x => mod(x - t)); }

function primeForm(set){
  // Work on the unique set (prime form ignores duplicates)
  const n1 = transposeToZero(normalOrder(set));
  const n2 = transposeToZero(normalOrder(invertSet(set)));
  // compare reversed lexicographically (largest to smallest) per standard practice
  const L = Math.max(n1.length, n2.length);
  for(let i = L-1; i >= 0; i--){
    const a = n1[i] !== undefined ? n1[i] : -1;
    const b = n2[i] !== undefined ? n2[i] : -1;
    if(a < b) return n1;
    if(a > b) return n2;
  }
  return n1;
}

function pfToString(pf){ return '(' + pf.join('') + ')'; }

/* ---------------------------
   Derived detection
   --------------------------- */
function arrayEq(a,b){
  if(!a || !b) return false;
  if(a.length !== b.length) return false;
  for(let i=0;i<a.length;i++) if(a[i] !== b[i]) return false;
  return true;
}

function analyzeDerivation(pcs){
  const trichords = [], tetrachords = [];
  for(let i=0;i<4;i++) trichords.push(pcs.slice(i*3, i*3+3));
  for(let i=0;i<3;i++) tetrachords.push(pcs.slice(i*4, i*4+4));

  const triPF = trichords.map(t => primeForm(t));
  const tetPF = tetrachords.map(t => primeForm(t));

  const triDerived = triPF.every(pf => arrayEq(pf, triPF[0]));
  const tetDerived = tetPF.every(pf => arrayEq(pf, tetPF[0]));

  return { trichords, tetrachords, triPF, tetPF, triDerived, tetDerived };
}

/* ---------------------------
   UI helpers
   --------------------------- */
function pcsToNames(pcs){ return pcs.map(p => PC_TO_NOTE[p]).join(', '); }
function setToNotes(set){ return set.map(p => PC_TO_NOTE[p]).join(' '); }
function setToNums(set){ return '(' + set.join(',') + ')'; }

function showError(msg){
  const box = document.getElementById('errorBox');
  box.textContent = msg;
  box.style.display = 'block';
  document.getElementById('results').style.display = 'none';
}
function clearError(){ document.getElementById('errorBox').style.display = 'none'; }

function resetExample(){ document.getElementById('rowInput').value = 'G F# A G# C C# A# B D# D F E'; }

function copyResults(){
  const ocpiText = document.getElementById('ocpi').textContent || '';
  const icText = document.getElementById('ic').textContent || '';
  const txt = 'OCPI: ' + ocpiText + '\\nIC: ' + icText;
  navigator.clipboard?.writeText(txt).then(()=>alert('Copied OCPI/IC to clipboard'), ()=>alert('Copy failed'));
}

/* ---------------------------
   Main
   --------------------------- */
function runAnalysis(){
  clearError();
  const input = document.getElementById('rowInput').value;
  const {pcs, bad} = parseRow(input);
  if(bad.length) return showError('Could not parse tokens: ' + bad.join(', '));
  if(pcs.length !== 12) return showError('Please supply exactly 12 pitch-classes (parsed ' + pcs.length + ').');
  if(new Set(pcs).size !== 12) return showError('Parsed pitch-classes are not all distinct (duplicates detected).');

  const ocpi = ocpiSequence(pcs);
  const ic = icSequence(pcs);
  const ocpiPal = isPalindrome(ocpi);
  const icPal = isPalindrome(ic);
  const deriv = analyzeDerivation(pcs);

  document.getElementById('pcNums').textContent = pcs.join(', ');
  document.getElementById('pcNames').textContent = pcsToNames(pcs);
  document.getElementById('ocpi').textContent = ocpi.join(', ');
  document.getElementById('ocpiPal').textContent = 'Palindrome? ' + (ocpiPal ? 'Yes' : 'No');
  document.getElementById('ic').textContent = ic.join(', ');
  document.getElementById('icPal').textContent = 'Palindrome? ' + (icPal ? 'Yes' : 'No');

  // Trichords display
  const triRaw = deriv.trichords.map(s => setToNotes(s)).join(' | ');
  const triNums = deriv.trichords.map(s => '(' + s.join(',') + ')').join(' ');
  const triPFs = deriv.triPF.map(pfToString).join(' ');
  document.getElementById('triSets').textContent = triRaw + '\n' + triNums + ' → ' + triPFs;
  document.getElementById('triResult').textContent = 'Trichord-derived? ' + (deriv.triDerived ? 'YES' : 'NO');

  // Tetrachords display
  const tetRaw = deriv.tetrachords.map(s => setToNotes(s)).join(' | ');
  const tetNums = deriv.tetrachords.map(s => '(' + s.join(',') + ')').join(' ');
  const tetPFs = deriv.tetPF.map(pfToString).join(' ');
  document.getElementById('tetSets').textContent = tetRaw + '\n' + tetNums + ' → ' + tetPFs;
  document.getElementById('tetResult').textContent = 'Tetrachord-derived? ' + (deriv.tetDerived ? 'YES' : 'NO');

  document.getElementById('results').style.display = 'block';
}
</script>
</body>
</html>

