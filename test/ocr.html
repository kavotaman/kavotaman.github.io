<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>OCR + Transpose — Monospace Chord Editor</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 18px; }
    h1 { margin-top: 0; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    label { display:inline-block; margin-right:8px; }
    #editor { width:100%; height:300px; font-family: "Courier New", Courier, monospace; font-size:14px; white-space:pre; box-sizing:border-box; }
    #render { width:100%; min-height:200px; font-family: "Courier New", Courier, monospace; white-space:pre; border:1px solid #ddd; padding:8px; box-sizing:border-box; }
    .controls { margin:10px 0; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { padding:6px 10px; }
    .progress { margin-top:8px; }
    .chord { background: #fffa8f; font-weight:700; }
    #dropZone { border:2px dashed #bbb; padding:12px; text-align:center; color:#666; }
    small { color:#666; }
  </style>
  <!-- PDF.js -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
</head>
<body>
  <h1>PDF/Image → OCR → Monospace Chord Editor (client-side)</h1>

  <div class="row">
    <div style="flex:1 1 420px;">
      <div id="dropZone">Drop PDF or image here, or <input id="fileInput" type="file" accept="application/pdf,image/*" /></div>
      <div class="controls">
        <button id="startOcrBtn">OCR & Insert into editor</button>
        <button id="clearBtn">Clear editor</button>
        <div style="margin-left:auto;">
          <label for="pageScale">OCR scale:</label>
          <select id="pageScale"><option>1.5</option><option selected>2</option><option>3</option></select>
          <small> (higher = better OCR, slower)</small>
        </div>
      </div>

      <div class="progress" id="progressArea"></div>
    </div>
  </div>

  <h3>Editor (monospace)</h3>
  <textarea id="editor" placeholder="OCR result will appear here..."></textarea>

  <div class="controls">
    <label for="transposeAmount">Transpose</label>
    <button data-step="-12" class="transposeBtn">-12</button>
    <button data-step="-7" class="transposeBtn">-7</button>
    <button data-step="-5" class="transposeBtn">-5</button>
    <button data-step="-2" class="transposeBtn">-2</button>
    <input id="transposeAmount" type="number" step="1" value="1" style="width:60px" />
    <button id="transposeApply">Apply</button>

    <label style="margin-left:12px;">Preview:</label>
    <button id="renderBtn">Render & Highlight</button>
    <button id="downloadTxt">Download .txt</button>
  </div>

  <h3>Rendered View (highlighted chords)</h3>
  <div id="render"></div>

  <script>
  // ---------- Config ----------
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

  const fileInput = document.getElementById('fileInput');
  const dropZone = document.getElementById('dropZone');
  const startOcrBtn = document.getElementById('startOcrBtn');
  const progressArea = document.getElementById('progressArea');
  const editor = document.getElementById('editor');
  const renderArea = document.getElementById('render');
  const pageScaleSelect = document.getElementById('pageScale');
  const transposeAmountInput = document.getElementById('transposeAmount');
  const transposeApply = document.getElementById('transposeApply');
  const renderBtn = document.getElementById('renderBtn');
  const downloadTxt = document.getElementById('downloadTxt');
  let selectedFile = null;

  // ---------- File handling ----------
  dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.style.borderColor = '#888'; });
  dropZone.addEventListener('dragleave', e => { dropZone.style.borderColor = '#bbb'; });
  dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.style.borderColor = '#bbb';
    if (e.dataTransfer.files && e.dataTransfer.files.length) {
      selectedFile = e.dataTransfer.files[0];
      fileInput.files = e.dataTransfer.files;
      progressArea.textContent = 'File selected: ' + selectedFile.name;
    }
  });

  fileInput.addEventListener('change', e => {
    if (fileInput.files && fileInput.files[0]) {
      selectedFile = fileInput.files[0];
      progressArea.textContent = 'File selected: ' + selectedFile.name;
    }
  });

  // ---------- OCR main ----------
  startOcrBtn.addEventListener('click', async () => {
    if (!selectedFile) { alert('Please select a PDF or image first.'); return; }
    progressArea.textContent = 'Preparing OCR...';
    const scale = parseFloat(pageScaleSelect.value) || 2;
    try {
      let canvases = [];
      if (selectedFile.type === 'application/pdf' || selectedFile.name.toLowerCase().endsWith('.pdf')) {
        canvases = await renderPdfToCanvases(selectedFile, scale);
      } else {
        const img = await loadImageFromFile(selectedFile);
        canvases = [imageToCanvas(img, scale)];
      }

      let finalText = '';
      for (let i = 0; i < canvases.length; i++) {
        progressArea.textContent = `OCR: page ${i+1}/${canvases.length}...`;
        const words = await recognizeCanvasWords(canvases[i], progress => {
          progressArea.textContent = `OCR page ${i+1}: ${Math.round(progress * 100)}%`;
        });
        const txt = reconstructMonospaceFromWords(words, canvases[i].width);
        finalText += txt + (i + 1 < canvases.length ? '\n\n' : '');
      }

      // Cleanup spacing before displaying
      const cleaned = cleanupLyricsSpacing(finalText);
      editor.value = cleaned;
      progressArea.textContent = 'OCR complete. Text inserted into editor.';
      renderHighlighted();
    } catch (err) {
      console.error(err);
      alert('OCR failed: ' + err.message);
    }
  });

  // ---------- Helpers ----------
  async function renderPdfToCanvases(file, scale=2) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({data:arrayBuffer}).promise;
    const canvases = [];
    for (let p = 1; p <= pdf.numPages; p++) {
      const page = await pdf.getPage(p);
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement('canvas');
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      const ctx = canvas.getContext('2d');
      await page.render({ canvasContext: ctx, viewport }).promise;
      canvases.push(canvas);
    }
    return canvases;
  }

  function loadImageFromFile(file) {
    return new Promise((res, rej) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); res(img); };
      img.onerror = e => { URL.revokeObjectURL(url); rej(e); };
      img.src = url;
    });
  }

  function imageToCanvas(img, scale=2) {
    const canvas = document.createElement('canvas');
    canvas.width = Math.floor(img.naturalWidth * scale);
    canvas.height = Math.floor(img.naturalHeight * scale);
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas;
  }

  async function recognizeCanvasWords(canvas, onProgress) {
    return new Promise((resolve, reject) => {
      Tesseract.recognize(canvas, 'eng', {
        logger: m => { if (m.status === 'recognizing text' && onProgress && m.progress) onProgress(m.progress); }
      })
      .then(result => {
        const words = (result.data.words || []).map(w => {
          const bbox = w.bbox || w.box || {x0: w.x0||0, y0: w.y0||0, x1: w.x1||0, y1: w.y1||0};
          return { text: (w.text || '').replace(/\n/g,'').trim(), bbox };
        }).filter(w => w.text);
        resolve(words);
      })
      .catch(reject);
    });
  }

  // ---------- Reconstruct + cleanup ----------
  function reconstructMonospaceFromWords(words, canvasWidth) {
    if (!words || words.length === 0) return '';
    const lines = [];
    const threshold = 10;
    for (const w of words) {
      const ycenter = ((w.bbox.y0 + w.bbox.y1) / 2);
      let placed = false;
      for (const line of lines) {
        if (Math.abs(line.avgY - ycenter) <= threshold) {
          line.words.push({...w, ycenter});
          line.avgY = (line.avgY * line.count + ycenter) / (++line.count);
          placed = true; break;
        }
      }
      if (!placed) lines.push({ avgY: ycenter, words: [{...w, ycenter}], count:1 });
    }
    lines.sort((a,b) => a.avgY - b.avgY);
    const tmp = document.createElement('canvas');
    const ctx = tmp.getContext('2d');
    ctx.font = `14px Courier New, monospace`;
    const charWidth = ctx.measureText('M').width || 8;
    const cols = Math.max(40, Math.floor(canvasWidth / charWidth));
    const reconstructed = lines.map(line => {
      const arr = new Array(cols).fill(' ');
      line.words.sort((a,b) => a.bbox.x0 - b.bbox.x0);
      for (const w of line.words) {
        const col = Math.max(0, Math.min(cols-1, Math.floor(w.bbox.x0 / charWidth)));
        const token = w.text;
        for (let i=0;i<token.length && (col+i)<cols;i++) arr[col+i] = token[i];
        if ((col + token.length) < cols) arr[col + token.length] = ' ';
      }
      return arr.join('').replace(/\s+$/,'');
    });
    return reconstructed.join('\n');
  }

  // ---------- Hybrid cleanup: preserves chord spacing alignment ----------
function cleanupLyricsSpacing(text) {
  const lines = text.split('\n');
  return lines.map(line => {
    const trimmed = line.trim();

    // Detect chord-only lines (uppercase + symbols)
    const chordLike = /^[\sA-G#b0-9\/\+\-\(\)]+$/.test(trimmed);
    if (chordLike) return line; // keep chord lines as-is

    const leadingSpaces = line.match(/^\s*/)?.[0] || '';

    // Smart tightening:
    // 1. Replace huge gaps (4+ spaces) between *letters* with single spaces.
    // 2. But if gap follows a chord-like token (A–G etc.), keep at least 6 spaces for alignment.
    let result = line;

    // Step 1: Protect chord-followed spacing with marker
    result = result.replace(/([A-G][#b]?(?:maj|min|m|dim|aug|sus|add|M)?\d{0,2})(\s{3,})(?=[A-G])/g, (m, chord, spaces) => chord + '§'.repeat(spaces.length));

    // Step 2: Collapse large gaps elsewhere
    result = result.replace(/(\S)\s{3,}(\S)/g, '$1 $2');

    // Step 3: Restore protected chord spacing as ~6 spaces
    result = result.replace(/§{3,}/g, '      ');

    return leadingSpaces + result.trimEnd();
  }).join('\n');
}

  // ---------- Rendering ----------
  function renderHighlighted() {
    const txt = editor.value || '';
    const chordRegex = /([A-G](?:#|b)?(?:(?:maj|min|m|dim|aug|sus|add|M)?\d{0,2})?(?:\/[A-G](?:#|b)?)?(?:\-[0-9])?)/g;
    const lines = txt.split('\n');
    const htmlLines = lines.map(line => {
      const tokens = line.split(/(\s+)/);
      const transformed = tokens.map(tok => {
        if (tok.trim() === '') return tok;
        const isChordLike = chordRegex.test(tok) && !/[a-z]/.test(tok);
        chordRegex.lastIndex = 0;
        return isChordLike ? `<span class="chord">${tok}</span>` : tok;
      }).join('');
      return transformed;
    });
    renderArea.innerHTML = htmlLines.join('\n').replace(/\n/g, '<br/>');
  }

  editor.addEventListener('input', renderHighlighted);
  renderBtn.addEventListener('click', renderHighlighted);
  document.getElementById('clearBtn').addEventListener('click', () => { editor.value=''; renderArea.innerHTML=''; });
  </script>
</body>
</html>

